<!--
Copyright 2018 Google LLC

Use of this source code is governed by an MIT-style
license that can be found in the LICENSE file or at
https://opensource.org/licenses/MIT.
=============================================================================
-->

<!doctype html>
<head>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
  <script src="../dist/tfjs_layers.debug.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,700" type="text/css">
</head>

<style>
  body {
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    margin-top: 50px;
    margin-left: 50px;
  }
  .equation-div {
    font-family: monospace;
    margin-bottom: 1em;
  }
  .input-div {
    margin-bottom: 1em;
  }
  input {
    width: 5em;
    text-align: center;
  }
</style>

<body>
  <h1>TensorFlow.js Layers: Polynomial Regression Training Demo</h1>
  <div>
    <canvas id="canvas" height="600" width="800"></canvas>
  </div>
  <div>
    <div class="equation-div">
      <div>Truth equation:</div>
      <span>y =</span>
      <input id="cubic-coeff" value="6e-6"></input>
      <span>* x^3 +</span>
      <input id="quad-coeff" value="-2e-3"></input>
      <span>* x^2 +</span>
      <input id="linear-coeff" value="0.1"></input>
      <span>* x +</span>
      <input id="const-coeff" value="10"></input>
    </div>
    <div class="input-div">
      <span>Learning rate:</span>
      <input id="learning-rate" value="0.5"></input>
    </div>
    <div class="input-div">
      <span>Epochs:</span>
      <input id="epochs" value="40"></input>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const order = 3;

    // Convert world coordinates to canvas ones.
    function world2canvas(canvas, x, y) {
      return [x + canvas.width / 2, - y + canvas.height / 2];
    }

    // Draw x and y axes in the canvas.
    function drawAxes(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      const leftCoord = world2canvas(canvas, -canvas.width / 2, 0);
      const rightCoord = world2canvas(canvas, canvas.width / 2, 0);
      ctx.moveTo(leftCoord[0], leftCoord[1]);
      ctx.lineTo(rightCoord[0], rightCoord[1]);
      ctx.stroke();
      const topCoord = world2canvas(canvas, 0, canvas.height / 2);
      const bottomCoord = world2canvas(canvas, 0, -canvas.height / 2);
      ctx.moveTo(topCoord[0], topCoord[1]);
      ctx.lineTo(bottomCoord[0], bottomCoord[1]);
      ctx.stroke();
    }

    // Draw x and y data in the canvas.
    //
    // Also draws the x and y axes.
    //
    // Args:
    //   canvas: The canvas to draw the data in.
    //   xyData: An Array of [x, y] Arrays.
    function drawXYData(canvas, xyData) {
      drawAxes(canvas);
      const ctx = canvas.getContext('2d');
      for (let i = 0; i < xyData.length; ++i) {
        ctx.beginPath();
        const x = xyData[i][0];
        const y = xyData[i][1];
        const canvasCoord = world2canvas(canvas, x, y);
        ctx.arc(canvasCoord[0], canvasCoord[1], 4, 0, Math.PI * 2, true);
        ctx.stroke();
      }
    }

    // Calculate the arithmetic mean of a vector.
    //
    // Args:
    //   vector: The vector represented as an Array of Numbers.
    //
    // Returns:
    //   The arithmetic mean.
    function mean(vector) {
      let sum = 0;
      for (const x of vector) {
        sum += x;
      }
      return sum / vector.length;
    }

    // Calculate the standard deviation of a vector.
    //
    // Args:
    //   vector: The vector represented as an Array of Numbers.
    //
    // Returns:
    //   The standard deviation.
    function stddev(vector) {
      let squareSum = 0;
      const vectorMean = mean(vector);
      for (const x of vector) {
        squareSum += (x - vectorMean) * (x - vectorMean);
      }
      return Math.sqrt(squareSum / (vector.length - 1));
    }

    // Normalize a vector by its mean and standard deviation.
    function normalizeVector(vector, vectorMean, vectorStddev) {
      return vector.map(x => (x - vectorMean) / vectorStddev);
    }

    // Convert x-y data to normalized deeplearn.js Tensors.
    //
    // Args:
    //   xyData: An Array of [x, y] Number Arrays.
    //   order: The order of the polynomial to generate data for. Assumed to be
    //     a non-negative integer.
    //
    // Returns: An array consisting of the following
    //   xPowerMeans: Arithmetic means of the powers of x, from order `1` to
    //      order `order`
    //   xPowerStddevs: Standard deviations of the powers of x.
    //   Normalized powers of x: an Tensor2D of shape [batchSize, order + 1].
    //     The first column is all ones; the following columns are powers of x
    //     from order `1` to `order`.
    //   yMean: Arithmetic mean of y.
    //   yStddev: Standard deviation of y.
    //   Normalized powers of y: an Tensor2D of shape [batchSize, 1].
    function toNormalizedTensors(xyData, order) {
      const batchSize = xyData.length;
      const data = [];
      const xData = xyData.map(xy => xy[0]);
      const yData = xyData.map(xy => xy[1]);
      const yMean = mean(yData);
      const yStddev = stddev(yData);
      const yNormalized = normalizeVector(yData, yMean, yStddev);
      const normalizedXPowers = [];
      const xPowerMeans = [];
      const xPowerStddevs = [];
      for (let i = 0; i < order; ++i) {
        const xPower = xData.map(x => Math.pow(x, i + 1));
        const xPowerMean = mean(xPower);
        xPowerMeans.push(xPowerMean);
        const xPowerStddev = stddev(xPower);
        xPowerStddevs.push(xPowerStddev);
        const normalizedXPower = normalizeVector(xPower,
                                                 xPowerMean,
                                                 xPowerStddev);
        normalizedXPowers.push(normalizedXPower);
      }
      const xArrayData = [];
      for (let i = 0; i < xData.length; ++i) {
        for (let j = 0; j < order + 1; ++j) {
          if (j === 0) {
            xArrayData.push(1);
          } else {
            xArrayData.push(normalizedXPowers[j - 1][i]);
          }
        }
      }
      return [xPowerMeans, xPowerStddevs,
              tfjs_layers.dl.tensor2d(xArrayData, [batchSize, order + 1]),
              yMean, yStddev,
              tfjs_layers.dl.tensor2d(yNormalized, [batchSize, 1])];
    }

    // Fit a model for polynomial regression.
    //
    // Args:
    //   xyData: An Array of [x, y] Number Arrays.
    //   epochs: How many epochs to train for.
    //   learningRate: Learning rate.
    //
    // Returns: An Array consiting of the following:
    //   The trained keras Model instance.
    //   xPowerMeans: Arithmetic means of the powers of x, from order `1` to
    //      order `order`
    //   xPowerStddevs: Standard deviations of the powers of x.
    //   yMean: Arithmetic mean of y.
    //   yStddev: Standard deviation of y.
    async function fitModel(xyData, epochs, learningRate) {
      const batchSize = xyData.length;

      const outputs = toNormalizedTensors(xyData, order);
      const xPowerMeans = outputs[0];
      const xPowerStddevs = outputs[1];
      const xData = outputs[2];
      const yMean = outputs[3];
      const yStddev = outputs[4];
      const yData = outputs[5];

      const input = tfjs_layers.input({shape: [order + 1]});
      const linearLayer = tfjs_layers.layers.dense({
          units: 1,
          kernelInitializer: 'Zeros',
          useBias: false
      });
      const output = linearLayer.apply(input);
      const model = tfjs_layers.model({inputs: input, outputs: output});
      const sgd = new tfjs_layers.optimizers.SGD({lr: learningRate});
      model.compile({optimizer: sgd, loss: 'meanSquaredError'});

      await model.fit({
          x: xData,
          y: yData,
          batchSize: batchSize,
          epochs: epochs,
      });
      console.log('Model weights (normalized):',
                  model.trainableWeights[0].read().dataSync());
      return [model, xPowerMeans, xPowerStddevs, yMean, yStddev];
    }

    // Render the predictions made by the model.
    function renderModelPredictions(
        canvas, order, model, xPowerMeans, xPowerStddevs, yMean, yStddev) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      let x = -0.5 * width;
      const xStep = 0.02 * width;
      const xs = [];
      const xPowers = [];
      let n = 0;
      while (x < 0.5 * width) {
        xs.push(x);
        d = 1;
        for (let j = 0; j < order + 1; ++j) {
          xPowers.push(
              j === 0 ?
              d :
              ((d - xPowerMeans[j - 1]) / xPowerStddevs[j - 1]));
          d *= x;
        }
        x += xStep;
        n++;
      }
      const normalizedYs = model.predict(
          tfjs_layers.dl.tensor2d(xPowers, [n, order + 1])).dataSync();

      ctx.beginPath();
      let canvasXY = world2canvas(
          canvas, xs[0], normalizedYs[0] * yStddev + yMean);
      ctx.moveTo(canvasXY[0], canvasXY[1]);
      for (let i = 1; i < n; ++i) {
        canvasXY = world2canvas(
            canvas, xs[i], normalizedYs[i] * yStddev + yMean);
        ctx.lineTo(canvasXY[0], canvasXY[1]);
        ctx.stroke();
      }
    }

    // Generate x-y data based on the size of the canvas.
    function generateXYData(canvas, coeffs) {
      const data = [];
      for (let x = -canvas.width / 2;
            x < canvas.width / 2;
            x += canvas.width / 25) {
        data.push([
            x,
            coeffs[0] * x * x * x + coeffs[1] * x * x + coeffs[2] * x + coeffs[3]]);
      }
      return data;
    }

    // Fit a model and render the data and predictions.
    async function fitAndRender() {
      const epochs = Number.parseInt($('#epochs').val());
      const learningRate = Number.parseFloat($('#learning-rate').val());
      if (!isFinite(epochs) || !isFinite(learningRate)) {
        return;
      }
      const coeffs = [
          Number.parseFloat($('#cubic-coeff').val()),
          Number.parseFloat($('#quad-coeff').val()),
          Number.parseFloat($('#linear-coeff').val()),
          Number.parseFloat($('#const-coeff').val()),
      ];
      console.log('Truth coefficients: ' + JSON.stringify(coeffs));

        let xyData = generateXYData(canvas, coeffs);
        drawXYData(canvas, xyData);

        const fitOutputs = await fitModel(xyData, epochs, learningRate);
        const model = fitOutputs[0];
        const xPowerMeans = fitOutputs[1];
        const xPowerStddevs = fitOutputs[2];
        const yMean = fitOutputs[3];
        const yStddev = fitOutputs[4];
        renderModelPredictions(
            canvas, order, model, xPowerMeans, xPowerStddevs, yMean, yStddev);
    }

    $('#cubic-coeff').keyup(fitAndRender);
    $('#quad-coeff').keyup(fitAndRender);
    $('#linear-coeff').keyup(fitAndRender);
    $('#const-coeff').keyup(fitAndRender);
    $('#epochs').keyup(fitAndRender);
    $('#learning-rate').keyup(fitAndRender);

    fitAndRender();

  </script>
</body>
