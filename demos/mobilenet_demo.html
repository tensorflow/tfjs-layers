<!--
Copyright 2018 Google LLC

Use of this source code is governed by an MIT-style
license that can be found in the LICENSE file or at
https://opensource.org/licenses/MIT.
=============================================================================
-->

<!doctype html>

<head>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
  <script src="../dist/tfjs_layers.debug.js"></script>
</head>

<!-- TODO(bileschi) move styling to another file. -->
<style>
  .input-div {
    padding: 5px;
    font-family: monospace;
  }

  .predict-div {
    padding: 5px;
    padding-top: 20px;
  }

  .predict-table {
    font-family: monospace;
    table-layout: fixed;
    border-collapse: collapse;
    border: 1px solid black;
  }

  td {
    padding-left: 5px;
    padding-right: 5px;
    padding-bottom: 5px;
    border: 1px solid black;
  }

  .predict-header {
    font-weight: bold;
  }

  .output-div {
    padding: 5px;
    padding-top: 20px;
    font-family: monospace;
    font-weight: bold;
  }

  #image-input {
    font-family: monospace;
    position: relative;
    width: 100%;
  }

  .thumb {
    border: 0px solid #000;
    margin: 10px 5px 0 0;
  }
</style>

<body>
  <h1>TensorFlow.js Layers: MobileNet Demo</h1>
  <!-- selector for image file -->
  <div>
    <span id="demo-status"></span>
  </div>
  <input type="file" id="files" name="files[]" multiple />
  <!-- ouptut holds the thumbnail / prediction pairs. -->
  <output id="imgs_and_predictions"></output>

  <script>
    (async () => {
      // How many predictions to make per image
      const NUM_PREDICTIONS = 10;

      // Builds the DOM elements for holding the image and prediction.
      // Returns the image span to attach the image to.
      function createOutputRow(idx) {
        let imgTableDiv = document.createElement('div');
        imgTableDiv.setAttribute('id', 'image-table-div-' + idx);
        document.getElementById('imgs_and_predictions').
          insertBefore(imgTableDiv, null);
        let imgSpan = document.createElement('span');
        imgSpan.setAttribute('id', 'img-span-' + idx);
        let tableSpan = document.createElement('span');
        imgTableDiv.append(imgSpan);
        imgTableDiv.append(tableSpan);
        let tableDiv = document.createElement('div');
        tableSpan.appendChild(tableDiv);
        let table = document.createElement('table');
        table.setAttribute('class', 'predict-table');
        tableDiv.append(table);
        // Fill the predictions table.
        let headerRow = document.createElement("tr");
        headerRow.setAttribute('class', 'predict-header');
        headerRow.setAttribute('id', 'predict-header-' + idx);
        let valueRow = document.createElement("tr");
        valueRow.setAttribute('id', 'predict-values-' + idx);
        table.appendChild(headerRow);
        table.appendChild(valueRow);
        return imgSpan
      }

      function handleFileSelect(evt) {
        let files = evt.target.files; // FileList object
        // Display thumbnails & issue call to predict each image.
        for (let i = 0, f; f = files[i]; i++) {
          // Only process image files (skip non image files)
          if (!f.type.match('image.*')) {
            continue;
          }
          let reader = new FileReader();
          const idx = i;
          // Closure to capture the file information.
          reader.onload = (function (theFile) {
            return function (e) {
              let imgSpan = createOutputRow(idx)
              // Fill the image & call predict.
              let img = document.createElement("img");
              imgSpan.appendChild(img);
              img.className = 'thumb';
              img.src = e.target.result;
              img.width = 224;
              img.height = 224;
              img.setAttribute('id', 'image-' + idx);
              img.onload = () => predict(img, idx);
            };
          })(f);

          // Read in the image file as a data URL.
          reader.readAsDataURL(f);
        }
      }

      document.getElementById('files').addEventListener('change', handleFileSelect, false);

      const demoStatus = $('#demo-status');
      const artifactsDir = '../../dist/demo/mobilenet/';

      // Load model.
      console.log('Loading model...');
      demoStatus.text('Loading model...');
      const model = await tfjs_layers.loadModel(artifactsDir + 'model.json');
      console.log('Done loading model.');
      demoStatus.text('');

      // Load the imagenet class names.
      console.log('Loading Imagenet class names...');
      demoStatus.text('Loading Imagenet class names...');
      const imagenetClasses =
          await (await fetch(artifactsDir + 'imagenet_class_names.json')).json();
      console.log('Done loading Imagenet class names:', imagenetClasses);
      demoStatus.text('');

      function topKIndices(inputArray, NUM_PREDICTIONS) {
        let copyArray = inputArray.slice()
        let idxs = [];
        for (let i = 0; i < NUM_PREDICTIONS; ++i) {
          idx = _.indexOf(copyArray, _.max(copyArray));
          idxs.push(idx);
          copyArray[idx] = -Infinity;
        }
        return idxs;
      }

      // Normalizes input [0, 256] to between [-1, 1) and returns in batch-shape.
      //
      // TODO(bileschi): This function should be tightend up once DLJS
      // Handles `fromPixels` data correctly.
      // BUG: https://github.com/PAIR-code/deeplearnjs/issues/617
      function preprocessImg(rawImg) {
        return tfjs_layers.backend.scalarTimesArray(
          tfjs_layers.dl.scalar(1.0 / 127.0),
          tfjs_layers.backend.scalarPlusArray(
            tfjs_layers.dl.scalar(-127.0),
            tfjs_layers.backend.add(
              tfjs_layers.dl.fromPixels(rawImg).asType('float32'),
              tfjs_layers.dl.scalar(0.0)).reshape([1, 224, 224, 3])));
      }

      // Perform prediction for mnist on the input image using the loaded model.
      function predict(img, idx) {
        let batchInput = preprocessImg(img);
        const predictOut = Array.from(model.predict(batchInput).dataSync());
        const topK = topKIndices(predictOut, NUM_PREDICTIONS);

        $('#predict-header-' + idx).empty();
        for (let i = 0; i < NUM_PREDICTIONS; ++i) {
          const titleTd = $('<td>' + imagenetClasses[topK[i]] + '</td>')
          $('#predict-header-' + idx).append(titleTd);
        }
        $('#predict-values' + idx).empty();
        for (let i = 0; i < NUM_PREDICTIONS; ++i) {
          const valTd = $('<td>' + predictOut[topK[i]].toFixed(5) + '</td>');
          $('#predict-values-' + idx).append(valTd);
        }
      }
    })();
  </script>
</body>
